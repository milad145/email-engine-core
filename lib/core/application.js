import dotenv from 'dotenv';import db from '../data/db.js'import {ObjectId} from "mongodb";import {Client} from "@microsoft/microsoft-graph-client";import axios from "axios";import querystring from "querystring";import {decrypt, encrypt} from "../utils/utility.js";dotenv.config();const application = {    /**     * Add new Outlook email if it doesn't exist     * @param accessToken {String}     * @param refreshToken {String}     * @param aud {String}     * @param name {String}     * @param email {String}     * @param oid {String}     * @param tid {String}     * @param nonce {String}     * @returns {Promise<Object>}     */    azureLogin: (accessToken, refreshToken, aud, name, email, oid, tid, nonce) => {        return db.user.addUser('azure', accessToken, refreshToken, aud, email, name, oid, {tid, nonce})    },    /**     * Sync client emails     * @param user {String}     * @param accessToken {String}     * @param folder {String}     * @param tryTimes {Number}     * @returns {Promise<Array>}     */    syncMails: (user, accessToken, folder, tryTimes = 0) => {        let userID = new ObjectId(user);        let mailFolders = {};        let messageUrl = "/me/messages"        if (folder !== 'all')            messageUrl = `/me/mailFolders/${folder.replace(/ /g, '')}/messages`        return new Promise((resolve, reject) => {            let client = Client.init({                authProvider: (done) => {                    done(null, accessToken);                }            });            return client.api("/me/mailFolders")                .get()                .then(response => {                    response.value.forEach(f => mailFolders[f.id] = f.displayName)                    return client.api(messageUrl)                        .select('subject,from,receivedDateTime,bodyPreview,parentFolderId,isRead')                        .top(30)                        .get();                })                .then(response => {                    response.value.forEach(async mail => {                        await db.mail.syncMail(userID, mail.id, mail.subject, {                            name: mail.from['emailAddress'].name,                            email: mail.from['emailAddress'].address                        }, new Date(mail['receivedDateTime']), mail['isRead'] ? 1 : 0, mail['bodyPreview'], mailFolders[mail['parentFolderId']])                    })                    return db.user.updateOne(userID, {lastSync: new Date, mailFolders: Object.values(mailFolders)})                })                .then(() => resolve({newAccessToken: accessToken}))                .catch(err => {                    if (err.statusCode && err.statusCode === 401 && tryTimes < 5)                        return application.renewAccessToken(user)                            .then(newAccessToken => resolve(application.syncMails(user, newAccessToken, folder, ++tryTimes)))                    else if (err.statusCode && err.statusCode === 401)                        resolve({logout: true})                    else                        reject(err)                })        })    },    /**     * Set Subscription webhook     * @param accessToken {String}     * @returns {Promise<unknown>}     */    setupSubscriptionsWebhook: (accessToken) => {        const client = Client.init({            authProvider: (done) => {                done(null, accessToken);            }        });        return new Promise((resolve, reject) => {            client.api('/subscriptions')                .post({                    changeType: 'created,updated,deleted',                    notificationUrl: 'https://yourapp.com/api/webhook',                    resource: 'me/messages',                    expirationDateTime: new Date(Date.now() + 3600 * 24 * 3).toISOString()                })                .then(() => {                    resolve();                })                .catch(err => {                    reject(err);                });        })    },    /**     * Sync mails after subscription notification     * @param userId {String}     */    syncSubscription: (userId) => {        return db.user.findOneByQuery({userId}, {accessToken: 1})            .then(user => {                let {_id, accessToken} = user;                accessToken = decrypt(accessToken)                return application.syncMails(_id.toString(), accessToken, 'all')            })    },    /**     * Get User Profile     * @param _id {String}     * @returns {Promise<Object>}     */    getProfileData: (_id) => {        let user = new ObjectId(_id)        return db.user.getUser(user, {mailFolders: 1, email: 1, lastLogin: 1, lastSync: 1})    },    /**     * Get User Mails     * @param _id {String}     * @param folder {String}     * @returns {Promise<Object>}     */    getUserMails: (_id, folder) => {        let user = new ObjectId(_id)        let mails        return db.mail.getUserMails(user, folder, {folder: 1, receivedAt: 1, sender: 1, status: 1, subject: 1})            .then(result => {                mails = result;                return db.user.getUser(user, {mailFolders: 1})            })            .then(user => {                return {mails, mailFolders: user.mailFolders}            })    },    /**     * Get Specific Mail for the owner     * @param user {String}     * @param mailId {String}     * @returns {Promise<Object>}     */    getMail(user, mailId) {        let owner = new ObjectId(user)        let _id = new ObjectId(mailId)        return db.mail.getUserMailInfo(_id, owner)    },    /**     * Renew expired access-token by refresh-token     * @param userId {String}     * @returns {Promise<Object|String>}     */    renewAccessToken(userId) {        return new Promise((resolve, reject) => {            let newAccessToken;            let _id = new ObjectId(userId)            return db.user.findOneByQuery({_id}, {refreshToken: 1})                .then(user => {                    if (!user)                        reject({logout: true})                    else {                        return axios.post(`https://login.microsoftonline.com/common/oauth2/v2.0/token`,                            querystring.stringify({                                grant_type: 'refresh_token',                                client_id: process.env.AZURE_AD_CLIENT_ID,                                client_secret: process.env.AZURE_AD_CLIENT_SECRET,                                refresh_token: decrypt(user.refreshToken),                                scope: ['email', 'profile', 'openid', 'offline_access', 'Mail.Read']                            }), {headers: {"Content-Type": "application/x-www-form-urlencoded"}}                        )                            .then(response => {                                newAccessToken = response.data.access_token                                return db.user.updateOne(_id, {accessToken: encrypt(newAccessToken)})                            })                            .then(() => resolve(newAccessToken))                            .catch(error => reject(error));                    }                })        })    }}export default application