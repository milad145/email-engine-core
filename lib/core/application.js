import dotenv from 'dotenv';import db from '../data/db.js'import {ObjectId} from "mongodb";import {Client} from "@microsoft/microsoft-graph-client";dotenv.config();const application = {    /**     * Add new Outlook email if it doesn't exist     * @param accessToken {String}     * @param refreshToken {String}     * @param aud {String}     * @param name {String}     * @param email {String}     * @param oid {String}     * @param tid {String}     * @param nonce {String}     * @returns {Promise<Object>}     */    azureLogin: (accessToken, refreshToken, aud, name, email, oid, tid, nonce) => {        return db.user.addUser('azure', accessToken, refreshToken, aud, email, name, {oid, tid, nonce})    },    /**     * Sync client emails     * @param user {String}     * @param accessToken {String}     * @returns {Promise<Array>}     */    syncMails: (user, accessToken) => {        let userID = new ObjectId(user);        let mailFolders = {};        return new Promise((resolve, reject) => {            const client = Client.init({                authProvider: (done) => {                    done(null, accessToken);                }            });            return client.api("/me/mailFolders")                .get()                .then(response => {                    response.value.forEach(f => mailFolders[f.id] = f.displayName)                    return client.api("/me/message")                        .select('subject,from,receivedDateTime,bodyPreview,parentFolderId')                        .top(10)                        .get();                })                .then(response => {                    response.value.forEach(async mail => {                        await db.mail.syncMail(userID, mail.id, mail.subject, {                            name: mail.from['emailAddress'].name,                            email: mail.from['emailAddress'].address                        }, new Date(mail['receivedDateTime']), mail['isRead'] ? 1 : 0, mail['bodyPreview'], mailFolders[mail['parentFolderId']])                    })                    return db.user.updateOne(userID, {lastSync: new Date})                })                .then(() => resolve(true))                .catch(err => {                    reject(err)                })        })    },    /**     * Get user info by user id     * @param _id {String}     */    getUserInfo: (_id) => {        return db.user.getUser(_id, {email: 1, accessToken: 1, refreshToken: 1})    }}export default application