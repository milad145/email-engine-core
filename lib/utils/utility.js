import http from "http";import https from "https";import crypto from "node:crypto";import Url from "url";export const appDir = process.env.PWD;const jwtKey = hash(process.env.JWT_KEY)const jwtIV = process.env.JWT_IV/** * Format IP address (removing ::ff characters) * @param address {String} * @returns {string|string|string} */export function formatIpAddress(address) {    if (typeof address === "string")        return address.startsWith("::ff" + "ff:") ? address.slice(7) : address;    else        return "Unknown IP";}/** * Handle Error Response * @param req {Object} * @param res {Object} * @param err {Object} */export function setErrorResponse(req, res, err) {    console.error("Processing request '%s %s' from '%s' failed:", req.method || "Unknown", req.originalUrl || "request", formatIpAddress(req.ip), err.message || err);    res.status(403).end();}/** * Handle custom response code such as 400,404,... * @param req {Object} * @param res {Object} * @param code {Object} */export function setResponseCode(req, res, code) {    console.error("Request '%s %s' from '%s' failed. Status Code: %d (%s)", req.method || "Unknown", req.originalUrl || "request", formatIpAddress(req.ip), code, http.STATUS_CODES[code]);    res.status(code).end();    if (code === 400)        console.debug(req.body);}/** * Hash a plain text message * @param message {String} * @returns {string} */export function hash(message) {    return crypto.createHash("md5")        .update(Buffer.from(message, "ascii"))        .digest("hex");}/** * Encrypt a plain text message * @param payload {String} * @returns {string} */export function encrypt(payload) {    const cipher = crypto.createCipheriv("AES-256-CBC", jwtKey, jwtIV);    let message = cipher.update(payload, "ascii", "hex");    message += cipher.final("hex");    return message;}/** * Decrypt an encrypted message * @param message {String} * @returns {string} */export function decrypt(message) {    const decipher = crypto.createDecipheriv("AES-256-CBC", jwtKey, jwtIV);    let payload = decipher.update(message, "hex", "ascii");    payload += decipher.final("ascii");    return payload;}/** * call http request for external APIs * @param url {String} * @param method {String} * @param body {Object} * @param statusCodes {Array<Number>} * @param bearerToken {String} * @returns {Promise<unknown>} */export function httpRequest(url, method, body, statusCodes, bearerToken) {    return new Promise((resolve, reject) => {        url = Url.parse(url)        let {hostname, path, protocol} = url        let headers = {};        if (bearerToken)            headers["Authorization"] = "Bearer " + bearerToken;        let options = {            hostname: hostname,            path: path,            method: method,            headers        };        let requestType = (protocol === 'https://') ? https : http;        const request = requestType.request(options, function (response) {            if ([200, 308].includes(response.statusCode)) {                let body = "";                response.on("data", (chunk) => body += chunk);                response.on("end", function () {                    if (typeof response.headers["content-type"] === "string" && response.headers["content-type"].includes("application/json")) {                        try {                            body = JSON.parse(body);                        } catch (e) {                            reject(new Error(`API call ${method} ${path} returned malformed response!`));                        }                    }                    resolve({statusCode: response.statusCode, body});                });            } else if (statusCodes.includes(response.statusCode))                resolve({statusCode: response.statusCode});            else                reject(new Error(`Server API call ${method} ${path} failed with status code ${response.statusCode} (${http.STATUS_CODES[response.statusCode]})`));        });        request.on("error", function (err) {            reject(err);        });        request.end();    })}